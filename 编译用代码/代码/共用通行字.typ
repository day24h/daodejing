/*
: 本文件向外暴露的函数有：
:     1. H获取共用通行字信息H: 返回列共用通行字的信息：需要注释列？共用通行字所在行？
*/

#import "字符.typ": H去文本两端H 

// 检测数组中，如果含有此规则内的字符，视为无共用通行字。
#let I数组-规则视同测试失败I = ("∟", "＝")

// 检测数组中，如果含有此规则内的字符，视为空字符串元素。
#let I数组-规则视同空字符串I = ("□", "〼")

// 检测数组中，如果含有此子规则内的字符，将相应子规则首个元素作为比较元素。
#let I数组-规则视同相等I = (
  ("無", "无"),
  ("啟", "開"),
  ("聽", "𦗟"),
  ("恆","恒","常","𠄨"),
  ("國", "邦"),
  ("謂", "胃"),
  ("衆", "眾"),
  ("已", "巳"),
  ("聖", "聲", "𦔻"),
  ("以", "㠯"),
  ("其", "亓", "丌"),
  ("頌", "容"),
  ("虚", "虛"),
  ("明", "眀"),
  ("僞", "偽"),
  ("棄", "弃"),
  ("餘", "余"),
  ("唯", "惟"),
  ("趮", "躁"),
  ("得", "𠭁"),
  ("後", "后"),
  ("德", "惪"),
  ("間", "閒"),
  ("卻", "却"),
  ("沒", "没"),
  ("蕪", "芜"),
  ("盜", "盗"),
  ("昏", "昬"),
  ("敗", "贁"),
  ("飢", "饑"),
  ("鷄", "雞"),
  ("離", "离"),
  ("焉", "歟", "呵", "乎", "虖", "兮", "邪", "旖"),
  ("户", "戶"),
  ("安", "案"),
  ("居", "處"),
  ("法", "灋"),
  ("脱", "脫"),
  ("涣", "渙"),
  ("若", "如"),
  ("絕", "絶"),
  ("汎", "泛", "氾"),
  ("埏", "挻"),
  ("盲", "盳"),
  ("田", "畋"),
  ("溪", "谿"),
  ("墮", "隳"),
  ("螫", "蠚"),
  ("耀", "燿"),
  ("四", "駟"),
  ("窺", "闚"),
  ("溥", "普"),
  ("敝", "蔽"),
  ("命", "令")
)

// 检查：重复定义。
#let I扁平化I = I数组-规则视同相等I.flatten()
#if  I扁平化I.dedup().len() != I扁平化I.len(){
  panic("_rule_same 含重复字", I扁平化I
        .filter(x => I扁平化I.filter(y => y == x).len() > 1)
        .first()
  )
}

// 辅助 H获取共用通行字信息H
#let I获得视同相等的首元素I(I无括号字符串I) = {
  for rule in I数组-规则视同相等I {
    if I无括号字符串I in rule {return rule.first()} 
  }
  return I无括号字符串I // 未找到则保持原值。
}

// 返回值：
// 需要注释列 ⮕ true or false
// 共用通行字所在行 ⮕ none or 数字
#let H获取共用通行字信息H(I数组-用于比较字I) = {

  // 去重前。
  
  if I数组-用于比较字I
     .filter(x => x in I数组-规则视同测试失败I).len() != 0{
    // 【存在视同测试失败的元素】根据测试数组中，是否含“（”或“〈”确定需要注释列。
    return (regex("（|〈") in I数组-用于比较字I.join(""), none)
  }
  
  let I数组-没有空字符串I = I数组-用于比较字I
      .map(x => if x in I数组-规则视同空字符串I {""} else {x})
      .filter(y => y != "")
  
  if I数组-没有空字符串I.len() <= 1 {
    // 【列中仅有1个字】根据测试数组中，是否含“（”或“〈”确定需要注释列。
    return (regex("（|〈") in I数组-用于比较字I.join("") , none)
  }

  // 去重后。
  
  let I数组-无重复元素I = I数组-没有空字符串I.dedup()
  
  let I数组-仅正文字无重I = I数组-无重复元素I
    .filter(x => not (x.starts-with(regex("（|〈"))))

  if I数组-仅正文字无重I.len() == 0 {
    // 【列中没有正文字】根据测试数组中，是否含“（”或“〈”确定需要注释列。
    return (regex("（|〈") in I数组-用于比较字I.join(""), none)
  }

  let I数组-无重复元素均转视同相等首元素I = I数组-无重复元素I
    .map( x => {
        if x.starts-with("（") { H去文本两端H(x, "（_）") } 
        else if x.starts-with("〈") { H去文本两端H(x, "〈_〉") }
        else { x }
    }).map(x => I获得视同相等的首元素I(x))
  
  if I数组-无重复元素均转视同相等首元素I.dedup().len() == 1 {
    
    let I数组-当前各字所属规则I = I数组-规则视同相等I
        .filter(rule => I数组-仅正文字无重I.first() in rule)
        .flatten()
        
    let I待查找共用通行字I = if I数组-当前各字所属规则I.len() == 0 {
        // 未找到匹配规则，说明没用过转换规则，各元素是直接相等。
        I数组-仅正文字无重I.first()
      } else {
        // 获取正文中，离所属规则中首元素最近或等于的那元素。
        I数组-仅正文字无重I.sorted(
            key: x => I数组-当前各字所属规则I.position(y => y == x)
        ).first()
      }
    
    return ( 
      "〈" in I数组-用于比较字I.join(""), // 是否需要注释列。
      I数组-用于比较字I.position(x => x == I待查找共用通行字I), // 共用通行字所在行。
    )
  } else {
    // I数组-无重复元素均转视同相等首元素I 去重后，有多个元素。
    return (regex("（|〈") in I数组-用于比较字I.join(""), none)
  }
}